# Lab Title: Implementing a Simple Parser for Arithmetic Expressions

Course: Formal Languages & Finite Automata

Author: Negai Marin

## Objectives

1. Understand the concepts of lexical analysis, parsing, and abstract syntax trees.
2. Implement a lexer to tokenize input text.
3. Build a parser to construct an abstract syntax tree (AST) from the tokens.
4. Visualize the AST for a given input expression.

## Implementation Description
### Lexer
The lexer is a crucial component of the implementation, responsible for converting the input text into tokens. It employs regular expressions to recognize different types of tokens such as integers, operators, and parentheses. By utilizing regular expressions, the lexer efficiently identifies and categorizes tokens, laying the foundation for the subsequent parsing process.
The lexer was implemented in Python using the `re` module for regular expressions. Each token type, such as integers, operators, and parentheses, was defined with a corresponding regular expression pattern to match. The lexer scans the input text character by character and identifies tokens based on these patterns. It skips whitespace characters and raises an error for invalid input characters.

### Parser
The parser is the core component responsible for constructing the abstract syntax tree (AST) from the tokens generated by the lexer. It employs a recursive descent parsing technique to recursively build the AST based on the syntactic rules of arithmetic expressions. The parser defines parsing rules for expressions, terms, and factors, ensuring that the resulting AST accurately represents the hierarchical structure of the input expression.
The parser was developed as a recursive descent parser in Python. Parsing rules were defined for different syntactic constructs, including expressions, terms, and factors. The parser recursively builds the abstract syntax tree (AST) by combining smaller syntactic units into larger ones. It uses a top-down approach, starting from the highest-level expression and recursively parsing sub-expressions.

### Abstract Syntax Tree (AST)
The AST serves as a structured representation of the syntactic structure of the input expression. It consists of nodes representing different syntactic constructs such as binary operations and numeric literals. By organizing the input expression into a hierarchical tree structure, the AST facilitates further analysis and manipulation of the expression, enabling tasks such as evaluation and optimization.
The AST was represented using Python classes for nodes in the tree. The `BinOp` class represents binary operations, such as addition, subtraction, multiplication, and division, while the `Num` class represents numeric literals. The AST reflects the hierarchical structure of the input expression, with parent nodes representing larger expressions composed of smaller sub-expressions.

### Conclusions / Results
The implementation of the lexer, parser, and abstract syntax tree (AST) successfully demonstrates the process of lexical analysis, parsing, and AST construction for simple arithmetic expressions. By tokenizing the input text, parsing it according to the syntactic rules, and constructing the AST, the implementation effectively translates the textual representation of arithmetic expressions into a structured form suitable for further analysis.

The visualization of the AST provides valuable insights into the syntactic structure of the input expression. By examining the hierarchical organization of nodes in the AST, one can gain a deeper understanding of how the parser interprets the syntactic rules and constructs the corresponding abstract representation. Overall, the implementation serves as a foundational step towards understanding compiler construction principles and formal language processing techniques.

